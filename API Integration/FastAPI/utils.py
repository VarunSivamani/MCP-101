import logging
import asyncio
from fastmcp.client import Client

async def generate_with_timeout(model, prompt, timeout=10):
    """
    Generate content from a model with a timeout.

    Args:
        model: A generative model object that has a `generate_content` method.
        prompt (str): The input prompt for the model.
        timeout (int, optional): Maximum time in seconds to wait for a response. Defaults to 10.

    Returns:
        The response object from the model if successful, or None if an exception occurs or timeout is reached.

    Behavior:
        Uses asyncio to run the model generation in a thread pool executor and waits for the result with a timeout.
        Logs any exceptions encountered.
    """
    try:
        loop = asyncio.get_event_loop()
        response = await asyncio.wait_for(
            loop.run_in_executor(
                None,
                lambda: model.generate_content(contents=prompt)
            ),
            timeout=timeout
        )
        return response
    except Exception as e:
        logging.error(e)
        return None


def extract_type(field: dict) -> str:
    """
    Return a readable type string from a FastMCP schema field.

    Args:
        field (dict): A dictionary representing a field schema from FastMCP's inputSchema.

    Returns:
        str: A string representing the type of the field. Examples: 'string', 'number', 'string | null', or 'unknown'.

    Behavior:
        - If the field has a direct 'type', returns it.
        - If the field has 'anyOf' (multiple possible types), returns a pipe-separated string of types.
        - Returns 'unknown' if no recognizable type information is found.
    """
    if not isinstance(field, dict):
        return "unknown"

    # Direct type
    if "type" in field:
        return field["type"]

    # Handle anyOf (e.g., string | null)
    if "anyOf" in field:
        types = []
        for option in field["anyOf"]:
            if isinstance(option, dict) and "type" in option:
                types.append(option["type"])
        if types:
            return " | ".join(types)

    return "unknown"


def parse_function_call(output: str):
    """
    Parse a model-generated FUNCTION_CALL string into tool name and arguments.

    Args:
        output (str): The model output in the format:
                      "FUNCTION_CALL: tool_name|key1=value1|key2=value2|..."

    Returns:
        tuple:
            - tool_name (str): The name of the MCP tool to call.
            - arguments_dict (dict): A dictionary of key-value pairs extracted from the FUNCTION_CALL string.

    Raises:
        ValueError: If the output does not start with 'FUNCTION_CALL:'.

    Behavior:
        - Converts numeric strings to int or float.
        - Converts 'null' to Python None.
        - Ignores positional arguments without '='.
    """
    prefix = "FUNCTION_CALL:"
    if not output.startswith(prefix):
        raise ValueError("Not a tool call")

    content = output[len(prefix):].strip()
    parts = content.split("|")

    tool_name = parts[0].strip()
    raw_args = parts[1:]

    def convert(v: str):
        v = v.strip()
        if v.lower() == "null":
            return None
        try:
            if "." in v:
                return float(v)
            return int(v)
        except:
            return v

    args_dict = {}
    for item in raw_args:
        if "=" not in item:
            continue
        key, value = item.split("=", 1)
        args_dict[key.strip()] = convert(value)

    return tool_name, args_dict


async def call_tool_from_model_output(output: str, mcp):
    """
    Execute an MCP tool call based on a model-generated FUNCTION_CALL string.

    Args:
        output (str): The FUNCTION_CALL string generated by the model.
        mcp: The FastMCP instance containing the registered tools.

    Returns:
        The result returned by the called MCP tool.

    Behavior:
        - Parses the FUNCTION_CALL string into tool name and argument dictionary.
        - Calls the tool asynchronously using FastMCP's Client interface.
        - Returns the tool's output.
    """
    tool_name, arguments = parse_function_call(output)

    async with Client(mcp) as client:
        result = await client.call_tool(
            tool_name,
            arguments=arguments
        )
        return result


def build_system_prompt(tool_block: str) -> str:
    """
    Build a system prompt for the E-Commerce MCP agent (untrimmed, preserves spacing).

    Args:
        tool_block (str): A string describing all available tools in the format:
                          "- tool_name: param1: type, param2: type - Description"

    Returns:
        str: The system prompt for the model, preserving all line breaks and spacing.
    """
    system_prompt = f"""
        You are an E-Commerce multi-tool agent.
        You must always use a tool to perform any action.
        You must never answer using natural language.

        **TOOLS AVAILABLE:**
        {tool_block}

        **OUTPUT RULES â€” FOLLOW THESE EXACTLY:**
        - When calling a tool, output:
        FUNCTION_CALL: tool_name|param1=value1|param2=value2|...

        - When the tool finishes, output:
        FINAL_ANSWER: <tool result>

        **STRICT FORMAT RULES:**
        Output only one line at a time: **either FUNCTION_CALL or FINAL_ANSWER.**
        - No full sentences.
        - No explanations.
        - No markdown.
        - No code blocks.
        - No backticks.
        - No extra spaces.
        - Do NOT invent data.
        - Do NOT act without calling a tool.

        Solve the task exactly using the required format.
    """
    return system_prompt